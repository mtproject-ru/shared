## Цель встречи

- Провести рефлексию текущего состояния проекта
- Зафиксировать проблемы разработки
- Определить новую архитектурную и организационную стратегию

---

## Основные проблемы

1. **Отсутствие асинхронности**
	- Компоненты разработки блокируют друг друга
		Бэкенд ждет, пока будет готова БД
		Фронтенд ждем, пока будет готов бэкенд
	
2. **Нет четких технических требований**
    - Задачи описаны поверхностно и не документируются
    
3. **Отсутствие документации**
    - Понимание функционала требует чтения кода
    
4. **Сложный деплой**
    - Разные версии инструментов и зависимостей
	    Если у кого-то нет постгреса, то ему приходится скачивать.
		Если у кого-то разная версия го, то ему приходится скачивать.
		Если мы добавим новый компонент, то его придется скачивать.
	
5. **Нет единой архитектуры**
    - Разный формат ответов и структуры данных
	    Один запрос возвращает строку, другой bool, третий JSON-объект

---

## Ключевые изменения в процессе разработки

1. Итеративный рефакторинг вместо полного переписывания
	Начинаем с новой структурой, старый код подтягиваем постепенно
    
2. Разделение проекта на server и website репозитории для дальнейшего расширения?
    Создаем отедльный гитхаб [mtproject-ru](https://github.com/mtproject-ru), в котором будут находиться все продукты данного проекта (сервер, сайт, мобильное и настольное приложения?)
    
3. Асинхронная работа над независимыми задачами
    Правильное распределение задач, чтобы избежать высокой зависимости одной части от другой (в плане разработки)
    
4. Введение тестирования
    Чтобы в конце проекта не возвращаться и не исправлять ошибки в самой первой функции, мы будем писать тесты и тестировать до посинения
    
5. Feature-based подход к разработке
    Если раньше мы разрабатывали каждый функционал отдельно, то сейчас весь функционал будет сгруппирован в фичи. Новой фичи не будет, пока не будет протестирована предыдущая
    
6. Онлайн-встречи при необходимости
    Из-за высокой загруженности студентов, нам придется проводить онлайн встречи в Яндекс Телемост (дискорд)

---

## Архитектурные решения

### Feature-based архитектура

- Работа ведется по фичам (полный цикл реализации)
    
- Каждая фича включает:
    
    - Модель
        
    - Репозиторий
        
    - Сервис
		
	- DTO
        
    - API endpoint
	    
	- Тесты

### Dependency Inversion / DI

- Использование интерфейсов вместо прямых зависимостей
    
- Преимущества:
    
    - Удобное тестирование
        
    - Слабая связанность
        
    - Подмена реализаций

---

## Структура server

Основные директории:

- `cmd` - точка входа
    
- `config` - конфигурации
    
- `database` - модели и репозитории
    
- `services` - бизнес-логика
    
- `web` - контроллеры и DTO
    
- `logs` - логи (папка локальная, в репозитории ей не место!)
    
- `migrations` - миграции БД

Дополнительно:

- `.env` - окружение
    
- Docker конфигурация

---

## Основные компоненты

- **Модель** - объект БД
    
- **Репозиторий** - доступ к данным
    
- **Сервис** - бизнес-логика
    
- **Контроллер** - обработка запросов
    
- **DTO** - безопасная передача данных
    
- **Response** - единый формат ответа

---

## Соглашения по коду (Styleguide)

- Проброс ошибок вверх по слоям
	Если ошибка возникла в репозитории, то выбрасываем ее в сервис. 
	В сервисе обрабатываем эту ошибку, если она влияет на результат работы сервиса, то создаем и пробрасываем в контроллер новую ошибку.
	В контроллере, если ошибка достаточно важная и/или редкая, то логируем (slog.Warn или slog.Error) и возвращаем ошибочный Response СО СТАТУСОМ!
    
- Создание ошибок в месте возникновения
	Все ошибки создаем «на месте поимки» с помощью errors.New или fmt.Errorf.
	Если ошибка встречается много раз (пр: NotFoundError для пользователя, события и т.п.), то выносим в отдельный модуль и создаем кастомную ошибку
    
- Логическая группировка кода
	Не писать всю логику для событий, пользователей, создания календаря и обработки строк к одном файле - лучше разбить на несколько. 
	Для фичей используется вышеупомянутая структура.
	Если утилита может использоватся во многих частях приложения, то выносим в отдельный модуль.
	Иначе пишем в файле, где эта утилита нужна, делая функцию приватной
    
- Инкапсуляция
	Если ваша функция нужна только в данном файле или данном пакете (pakage), то делаем ее приватной, чтобы другие модули не имели к ней доступ (а зачем она им, вдруг напакостят?)
    
- Осмысленные имена
	Если из названия функции или переменной не понятно, что она делает или за что отвечает, то пишем небольшую документацию. 
	Не боимся давать длинные имена, но если прям совсем длинно получается, то выделяем основную суть, а остальное пишем в документации.
    
- Документирование сложных участков
	Если функция сложна для понимания, то пишем небольшие пояснения к неясным блокам.
	Автору кода может быть все понятно, но если я приду, прочитаю функцию и не пойму, что она делает и как работает, то капец.
	Да и автор через неделю может забыть уже алгоритм, по которому писал функцию
    
- Двойная валидация входных данных
	Когда с фронта поступает какой либо объект в запросе (структура), то он, скорее всего, будет отвалидирован, но лучше провалидировать и на бэкенде во второй раз. 
	Почему? Безопасность: запрос может прийти не только с фронта, но и из curl, скрипта, атаки.
    
- Разделение властей
	Если в модуле, который писал другой человек, необходимо внести изменения, то лучше попросить об этом самого разработчика модуля
	
- Логирование важных действий
	Если возникает серьезная ситуация(пр1) или редкая ошибка(пр2), то используем slog.{Info, Warn, Error}.
	А так же, если происходит какое то важное и опасное действие, то тоже логируем, даже если нет ошибки (пр3)
	
	***Пр1:*** Пользователь с id = 123 пытался зайти в админ-панель без прав администратора. Неверный пароль...
	Вот с такими данными будет легде понять что пытался сделать пользователь и кого надо банить. Тут мы используем slog.Warn
	***Пр2:*** Пользователь с id = 1234 зашел в админ-панель без прав администратора. Но мы его кикнули...
	Что? Ну вот тут slog.Error
	***Пр3:*** Администратор с id = 12345 зашел в админ-панель...
	Тут ошибки нет, но лучше логировать slog.Info, так как достаточно важное действие
    

---

## Логирование

- `log.Fatalf` — критические ошибки
    
- `slog.Info` — важные действия
    
- `slog.Warn` — подозрительные ситуации
    
- `slog.Error` — ошибки выполнения
    

---

## Терминология

Основные понятия:

- ***Интерфейс*** - интерфейс, описание функционала без реализации
- ***Имплементация*** - реализация функционала, описанного в интерфейсе
- ***Инстанс*** - объект имплементации
- ***Модель*** - объект базы данных
- ***Миграция*** - изменение базы данных (добавление строк, изменение колонок и т.п.)
- ***ДТО***(дэтэошка) - объект для передачи данных в контроллеры (и некоторые функции)
- ***Эндпоинт*** - конечный адрес, на который отправляется запрос (пр: /api/users/create)
- ***Группа*** - совокупность эндпоинтов
- ***Хэндлер*** - функция, которая обрабатывает запрос на определенный эндпоинт
- ***Контроллер*** - совокупность хэндлеров, объединенных одной группой (пр: контроллер пользователей для всех /api/users/). Принимает запрос, передает его в сервис, возвращает ответ
- ***Репозиторий***(репо) - интерфейс и его стандартная имплементация для работы с БД. Он принимает только модели и возвращает только их же
- ***Сервис*** - интерфейс и его стандартная имплементация для связывания контроллера с репозиторием. Он занимается обработкой входящих данных, передает их в репозиторий и возвращает результат
- ***Модуль*** - совокупность схожего функционала (пр: модуль сервисов, модуль конфигурации)
- ***Фича*** - совокупность функционала, объединенного общим смыслом (пр: фича пользователя - модель пользователя, репо, контроллера

---

## Используемые инструменты

- Goose - миграции БД
    
- slog - логирование
    
- pgx / sqlx - работа с PostgreSQL
	
- Fiber (v3) - сервер
    
- Docker / Compose - контейнеризация
    

---

## Итог

Встреча зафиксировала переход проекта к:

- масштабируемой архитектуре
    
- асинхронному процессу разработки
    
- строгим соглашениям по стилю кода
    
- модульной feature-ориентированной структуре
    

Цель - повышение качества разработки, тестируемости и масштабируемости проекта.